<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lightweight Performance Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        button {
            padding: 8px 16px;
            background: #4a9eff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover { background: #357abd; }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4a9eff;
        }
        .stat-label {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        .charts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }
        .chart {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 15px;
        }
        .chart-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #4a9eff;
        }
        canvas {
            width: 100%;
            height: 250px;
            background: #000;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Lightweight Performance Demo</h1>
    
    <div class="controls">
        <button onclick="demo.generateData()">Generate Data</button>
        <button onclick="demo.startUpdates()">Start Updates</button>
        <button onclick="demo.stopUpdates()">Stop Updates</button>
        <button onclick="demo.exportData()">Export CSV</button>
        <select id="dataSize" onchange="demo.generateData()">
            <option value="100000">100K Rows</option>
            <option value="1000000">1M Rows</option>
            <option value="5000000">5M Rows</option>
            <option value="10000000">10M Rows</option>
        </select>
    </div>
    
    <div class="stats">
        <div class="stat">
            <div class="stat-value" id="totalRows">0</div>
            <div class="stat-label">Total Rows</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="updateRate">0</div>
            <div class="stat-label">Updates/sec</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="renderTime">0ms</div>
            <div class="stat-label">Render Time</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="memoryUsage">0MB</div>
            <div class="stat-label">Memory</div>
        </div>
    </div>
    
    <div class="charts">
        <div class="chart">
            <div class="chart-title">Strength - Histogram</div>
            <canvas id="chart0"></canvas>
        </div>
        <div class="chart">
            <div class="chart-title">Angle - Scatter</div>
            <canvas id="chart1"></canvas>
        </div>
        <div class="chart">
            <div class="chart-title">Category - Bar</div>
            <canvas id="chart2"></canvas>
        </div>
        <div class="chart">
            <div class="chart-title">Time - Line</div>
            <canvas id="chart3"></canvas>
        </div>
    </div>
    
    <script>
        class LightweightDemo {
            constructor() {
                this.data = null;
                this.isUpdating = false;
                this.updateInterval = null;
                this.charts = [];
                this.performanceMetrics = {
                    updateCount: 0,
                    lastUpdateTime: performance.now()
                };
                
                this.initialize();
            }
            
            initialize() {
                this.setupCharts();
                this.generateData();
                this.setupMemoryMonitoring();
            }
            
            setupCharts() {
                this.charts = [];
                for (let i = 0; i < 4; i++) {
                    const canvas = document.getElementById(`chart${i}`);
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas size for high DPI displays
                    const dpr = window.devicePixelRatio || 1;
                    canvas.width = canvas.offsetWidth * dpr;
                    canvas.height = canvas.offsetHeight * dpr;
                    ctx.scale(dpr, dpr);
                    
                    this.charts.push({ canvas, ctx, type: i });
                }
            }
            
            setupMemoryMonitoring() {
                setInterval(() => {
                    if (performance.memory) {
                        const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                        document.getElementById('memoryUsage').textContent = memoryMB + 'MB';
                    }
                }, 1000);
            }
            
            generateData() {
                const dataSize = parseInt(document.getElementById('dataSize').value);
                const startTime = performance.now();
                
                // Use TypedArrays for performance
                this.data = new Float32Array(dataSize * 4);
                
                // Generate data in chunks to avoid blocking UI
                const chunkSize = 100000;
                let currentSize = 0;
                
                const generateChunk = () => {
                    const endSize = Math.min(currentSize + chunkSize, dataSize);
                    
                    for (let i = currentSize; i < endSize; i++) {
                        const baseIndex = i * 4;
                        this.data[baseIndex] = Math.random() * 100;        // Strength
                        this.data[baseIndex + 1] = Math.random() * 360;    // Angle
                        this.data[baseIndex + 2] = Math.floor(Math.random() * 10); // Category
                        this.data[baseIndex + 3] = Math.random() * 1000;   // Time
                    }
                    
                    currentSize = endSize;
                    
                    if (currentSize < dataSize) {
                        // Continue with next chunk
                        requestIdleCallback ? requestIdleCallback(generateChunk) : setTimeout(generateChunk, 0);
                    } else {
                        // Data generation complete
                        const endTime = performance.now();
                        console.log(`Generated ${dataSize.toLocaleString()} rows in ${Math.round(endTime - startTime)}ms`);
                        
                        this.updateStats();
                        this.renderAllCharts();
                    }
                };
                
                generateChunk();
            }
            
            startUpdates() {
                if (this.isUpdating) return;
                
                this.isUpdating = true;
                this.updateInterval = setInterval(() => {
                    this.updateData();
                    this.renderAllCharts();
                }, 100);
                
                console.log('Started updates');
            }
            
            stopUpdates() {
                if (!this.isUpdating) return;
                
                this.isUpdating = false;
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                    this.updateInterval = null;
                }
                
                console.log('Stopped updates');
            }
            
            updateData() {
                if (!this.data) return;
                
                const dataLength = this.data.length / 4;
                const updateCount = Math.min(1000, Math.floor(dataLength * 0.01));
                
                // Update random subset of data
                for (let i = 0; i < updateCount; i++) {
                    const randomIndex = Math.floor(Math.random() * dataLength);
                    const baseIndex = randomIndex * 4;
                    
                    // Add noise to existing values
                    this.data[baseIndex] = Math.max(0, Math.min(100, this.data[baseIndex] + (Math.random() - 0.5) * 10));
                    this.data[baseIndex + 1] = (this.data[baseIndex + 1] + Math.random() * 10) % 360;
                    this.data[baseIndex + 3] = Math.max(0, Math.min(1000, this.data[baseIndex + 3] + (Math.random() - 0.5) * 20));
                }
                
                // Update performance metrics
                this.performanceMetrics.updateCount++;
                const now = performance.now();
                if (now - this.performanceMetrics.lastUpdateTime >= 1000) {
                    const updatesPerSecond = Math.round(this.performanceMetrics.updateCount * 1000 / (now - this.performanceMetrics.lastUpdateTime));
                    document.getElementById('updateRate').textContent = updatesPerSecond;
                    this.performanceMetrics.updateCount = 0;
                    this.performanceMetrics.lastUpdateTime = now;
                }
            }
            
            renderAllCharts() {
                const startTime = performance.now();
                
                this.charts.forEach((chart, index) => {
                    this.renderChart(chart, index);
                });
                
                const endTime = performance.now();
                document.getElementById('renderTime').textContent = Math.round(endTime - startTime) + 'ms';
            }
            
            renderChart(chart, index) {
                const ctx = chart.ctx;
                const canvas = chart.canvas;
                const fieldIndex = index;
                
                // Clear canvas
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Get field data
                const dataLength = this.data.length / 4;
                const fieldData = new Float32Array(dataLength);
                
                for (let i = 0; i < dataLength; i++) {
                    fieldData[i] = this.data[i * 4 + fieldIndex];
                }
                
                // Render based on chart type
                switch (chart.type) {
                    case 0: this.renderHistogram(ctx, canvas, fieldData); break;
                    case 1: this.renderScatter(ctx, canvas, fieldData); break;
                    case 2: this.renderBar(ctx, canvas, fieldData); break;
                    case 3: this.renderLine(ctx, canvas, fieldData); break;
                }
            }
            
            renderHistogram(ctx, canvas, data) {
                const width = canvas.width;
                const height = canvas.height;
                const margin = 40;
                const chartWidth = width - 2 * margin;
                const chartHeight = height - 2 * margin;
                
                // Calculate bins efficiently
                const binCount = 50;
                const bins = new Array(binCount).fill(0);
                const min = Math.min(...data);
                const max = Math.max(...data);
                const binSize = (max - min) / binCount;
                
                // Count data into bins
                for (let i = 0; i < data.length; i++) {
                    const binIndex = Math.min(Math.floor((data[i] - min) / binSize), binCount - 1);
                    bins[binIndex]++;
                }
                
                const maxBin = Math.max(...bins);
                
                // Draw histogram bars
                ctx.fillStyle = '#4a9eff';
                for (let i = 0; i < binCount; i++) {
                    const x = margin + (i / binCount) * chartWidth;
                    const barWidth = chartWidth / binCount - 1;
                    const barHeight = (bins[i] / maxBin) * chartHeight;
                    const y = height - margin - barHeight;
                    
                    ctx.fillRect(x, y, barWidth, barHeight);
                }
                
                this.drawAxes(ctx, canvas, margin);
            }
            
            renderScatter(ctx, canvas, data) {
                const width = canvas.width;
                const height = canvas.height;
                const margin = 40;
                const chartWidth = width - 2 * margin;
                const chartHeight = height - 2 * margin;
                
                // Sample data for performance
                const sampleSize = Math.min(1000, data.length);
                const step = Math.max(1, Math.floor(data.length / sampleSize));
                
                ctx.fillStyle = '#feca57';
                for (let i = 0; i < data.length; i += step) {
                    const x = margin + (i / data.length) * chartWidth;
                    const y = margin + (1 - data[i] / Math.max(...data)) * chartHeight;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                this.drawAxes(ctx, canvas, margin);
            }
            
            renderBar(ctx, canvas, data) {
                const width = canvas.width;
                const height = canvas.height;
                const margin = 40;
                const chartWidth = width - 2 * margin;
                const chartHeight = height - 2 * margin;
                
                // Group data into categories
                const categories = 10;
                const categoryData = new Array(categories).fill(0);
                
                for (let i = 0; i < data.length; i++) {
                    const category = Math.floor((data[i] / Math.max(...data)) * categories);
                    categoryData[Math.min(category, categories - 1)]++;
                }
                
                const maxCategory = Math.max(...categoryData);
                
                ctx.fillStyle = '#4ecdc4';
                for (let i = 0; i < categories; i++) {
                    const x = margin + (i / categories) * chartWidth;
                    const barWidth = chartWidth / categories - 2;
                    const barHeight = (categoryData[i] / maxCategory) * chartHeight;
                    const y = height - margin - barHeight;
                    
                    ctx.fillRect(x, y, barWidth, barHeight);
                }
                
                this.drawAxes(ctx, canvas, margin);
            }
            
            renderLine(ctx, canvas, data) {
                const width = canvas.width;
                const height = canvas.height;
                const margin = 40;
                const chartWidth = width - 2 * margin;
                const chartHeight = height - 2 * margin;
                
                // Sample data for smooth line
                const sampleSize = Math.min(500, data.length);
                const step = Math.max(1, Math.floor(data.length / sampleSize));
                
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < data.length; i += step) {
                    const x = margin + (i / data.length) * chartWidth;
                    const y = margin + (1 - data[i] / Math.max(...data)) * chartHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                this.drawAxes(ctx, canvas, margin);
            }
            
            drawAxes(ctx, canvas, margin) {
                const width = canvas.width;
                const height = canvas.height;
                const chartWidth = width - 2 * margin;
                const chartHeight = height - 2 * margin;
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                
                // X-axis
                ctx.beginPath();
                ctx.moveTo(margin, height - margin);
                ctx.lineTo(margin + chartWidth, height - margin);
                ctx.stroke();
                
                // Y-axis
                ctx.beginPath();
                ctx.moveTo(margin, margin);
                ctx.lineTo(margin, height - margin);
                ctx.stroke();
            }
            
            updateStats() {
                if (!this.data) return;
                
                const dataLength = this.data.length / 4;
                document.getElementById('totalRows').textContent = dataLength.toLocaleString();
            }
            
            exportData() {
                if (!this.data) return;
                
                const dataLength = this.data.length / 4;
                let csv = 'Strength,Angle,Category,Time\n';
                
                // Export sample for performance
                const sampleSize = Math.min(10000, dataLength);
                const step = Math.max(1, Math.floor(dataLength / sampleSize));
                
                for (let i = 0; i < dataLength; i += step) {
                    const baseIndex = i * 4;
                    csv += `${this.data[baseIndex]},${this.data[baseIndex + 1]},${this.data[baseIndex + 2]},${this.data[baseIndex + 3]}\n`;
                }
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `data_export_${dataLength.toLocaleString()}_rows.csv`;
                a.click();
                URL.revokeObjectURL(url);
                
                console.log(`Exported ${sampleSize.toLocaleString()} rows to CSV`);
            }
        }
        
        // Initialize demo
        let demo;
        window.addEventListener('load', () => {
            demo = new LightweightDemo();
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (!demo) return;
            
            switch (e.key) {
                case ' ': demo.isUpdating ? demo.stopUpdates() : demo.startUpdates(); break;
                case 'g': demo.generateData(); break;
                case 'e': demo.exportData(); break;
            }
        });
    </script>
</body>
</html>
