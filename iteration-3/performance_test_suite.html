<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Test Suite</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            background: #0a0a0a;
            color: #00ff00;
            font-size: 14px;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #00ff00;
            padding-bottom: 20px;
        }
        .test-section {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .test-title {
            color: #00ff00;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        .test-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        button {
            padding: 8px 16px;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
        }
        button:hover { background: #00cc00; }
        button:disabled { background: #666; cursor: not-allowed; }
        .test-results {
            background: #000;
            border: 1px solid #333;
            padding: 15px;
            border-radius: 4px;
            font-family: inherit;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: #00ff00;
            width: 0%;
            transition: width 0.3s ease;
        }
        .chart-container {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        canvas {
            width: 100%;
            height: 200px;
            background: #000;
            border: 1px solid #333;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        .metric {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #00ff00;
        }
        .metric-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        .warning {
            color: #ffaa00;
            font-weight: bold;
        }
        .error {
            color: #ff0000;
            font-weight: bold;
        }
        .success {
            color: #00ff00;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üöÄ Performance Test Suite</h1>
        <p>Benchmarking High-Performance Data Visualization</p>
    </div>
    
    <!-- Data Generation Performance Test -->
    <div class="test-section">
        <div class="test-title">üìä Data Generation Performance</div>
        <div class="test-controls">
            <button onclick="testSuite.testDataGeneration()">Test Data Generation</button>
            <button onclick="testSuite.testMemoryEfficiency()">Test Memory Efficiency</button>
            <button onclick="testSuite.testTypedArrayPerformance()">Test TypedArray vs Array</button>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="dataGenProgress"></div>
        </div>
        <div class="test-results" id="dataGenResults">Ready to test data generation performance...</div>
    </div>
    
    <!-- Chart Rendering Performance Test -->
    <div class="test-section">
        <div class="test-title">üé® Chart Rendering Performance</div>
        <div class="test-controls">
            <button onclick="testSuite.testChartRendering()">Test Chart Rendering</button>
            <button onclick="testSuite.testMultiChartPerformance()">Test Multi-Chart Performance</button>
            <button onclick="testSuite.testCanvasOptimization()">Test Canvas Optimization</button>
        </div>
        <div class="chart-container">
            <canvas id="testChart"></canvas>
        </div>
        <div class="test-results" id="chartResults">Ready to test chart rendering performance...</div>
    </div>
    
    <!-- Data Processing Performance Test -->
    <div class="test-section">
        <div class="test-title">‚ö° Data Processing Performance</div>
        <div class="test-controls">
            <button onclick="testSuite.testFiltering()">Test Filtering</button>
            <button onclick="testSuite.testSorting()">Test Sorting</button>
            <button onclick="testSuite.testAggregation()">Test Aggregation</button>
        </div>
        <div class="metrics-grid">
            <div class="metric">
                <div class="metric-value" id="filterTime">0ms</div>
                <div class="metric-label">Filter Time</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="sortTime">0ms</div>
                <div class="metric-label">Sort Time</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="aggTime">0ms</div>
                <div class="metric-label">Aggregation Time</div>
            </div>
        </div>
        <div class="test-results" id="processingResults">Ready to test data processing performance...</div>
    </div>
    
    <!-- Real-time Update Performance Test -->
    <div class="test-section">
        <div class="test-title">üîÑ Real-time Update Performance</div>
        <div class="test-controls">
            <button onclick="testSuite.startRealTimeTest()">Start Real-time Test</button>
            <button onclick="testSuite.stopRealTimeTest()">Stop Test</button>
            <button onclick="testSuite.testUpdateFrequency()">Test Update Frequency</button>
        </div>
        <div class="metrics-grid">
            <div class="metric">
                <div class="metric-value" id="updateRate">0</div>
                <div class="metric-label">Updates/sec</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="renderFPS">0</div>
                <div class="metric-label">Render FPS</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="cpuUsage">0%</div>
                <div class="metric-label">CPU Usage</div>
            </div>
        </div>
        <div class="test-results" id="realtimeResults">Ready to test real-time update performance...</div>
    </div>
    
    <!-- Memory and Resource Test -->
    <div class="test-section">
        <div class="test-title">üíæ Memory & Resource Usage</div>
        <div class="test-controls">
            <button onclick="testSuite.monitorMemory()">Start Memory Monitoring</button>
            <button onclick="testSuite.testGarbageCollection()">Test Garbage Collection</button>
            <button onclick="testSuite.testMemoryLeaks()">Test Memory Leaks</button>
        </div>
        <div class="metrics-grid">
            <div class="metric">
                <div class="metric-value" id="heapSize">0MB</div>
                <div class="metric-label">Heap Size</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="heapUsed">0MB</div>
                <div class="metric-label">Heap Used</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="memoryPressure">0%</div>
                <div class="metric-label">Memory Pressure</div>
            </div>
        </div>
        <div class="test-results" id="memoryResults">Ready to test memory and resource usage...</div>
    </div>
    
    <script>
        class PerformanceTestSuite {
            constructor() {
                this.testData = null;
                this.isRealTimeTesting = false;
                this.realTimeInterval = null;
                this.memoryMonitoring = false;
                this.memoryInterval = null;
                this.testChart = null;
                this.testChartCtx = null;
                
                this.initialize();
            }
            
            initialize() {
                this.setupTestChart();
                this.log('Performance Test Suite initialized', 'success');
            }
            
            setupTestChart() {
                const canvas = document.getElementById('testChart');
                this.testChartCtx = canvas.getContext('2d');
                
                // Set canvas size for high DPI
                const dpr = window.devicePixelRatio || 1;
                canvas.width = canvas.offsetWidth * dpr;
                canvas.height = canvas.offsetHeight * dpr;
                this.testChartCtx.scale(dpr, dpr);
            }
            
            log(message, type = 'info', target = 'dataGenResults') {
                const timestamp = new Date().toLocaleTimeString();
                const prefix = type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
                const logMessage = `[${timestamp}] ${prefix} ${message}\n`;
                
                const targetElement = document.getElementById(target);
                if (targetElement) {
                    targetElement.textContent += logMessage;
                    targetElement.scrollTop = targetElement.scrollHeight;
                }
                
                console.log(logMessage);
            }
            
            updateProgress(percentage, target = 'dataGenProgress') {
                const progressBar = document.getElementById(target);
                if (progressBar) {
                    progressBar.style.width = percentage + '%';
                }
            }
            
            // Data Generation Performance Tests
            async testDataGeneration() {
                this.log('Starting data generation performance test...', 'info', 'dataGenResults');
                
                const testSizes = [100000, 1000000, 5000000, 10000000];
                const results = [];
                
                for (let i = 0; i < testSizes.length; i++) {
                    const size = testSizes[i];
                    this.log(`Testing ${size.toLocaleString()} rows...`, 'info', 'dataGenResults');
                    
                    const startTime = performance.now();
                    const data = this.generateTestData(size);
                    const endTime = performance.now();
                    
                    const duration = endTime - startTime;
                    const rowsPerSecond = Math.round(size / (duration / 1000));
                    const memoryMB = Math.round(data.byteLength / 1024 / 1024);
                    
                    results.push({ size, duration, rowsPerSecond, memoryMB });
                    
                    this.log(`‚úì ${size.toLocaleString()} rows: ${Math.round(duration)}ms (${rowsPerSecond.toLocaleString()} rows/sec, ${memoryMB}MB)`, 'success', 'dataGenResults');
                    
                    this.updateProgress(((i + 1) / testSizes.length) * 100);
                    
                    // Small delay to prevent UI blocking
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                this.log('Data generation performance test completed!', 'success', 'dataGenResults');
                this.log(`\nPerformance Summary:\n${results.map(r => 
                    `${r.size.toLocaleString()} rows: ${Math.round(r.duration)}ms, ${r.rowsPerSecond.toLocaleString()} rows/sec, ${r.memoryMB}MB`
                ).join('\n')}`, 'info', 'dataGenResults');
                
                this.updateProgress(100);
            }
            
            generateTestData(size) {
                // Use TypedArrays for maximum performance
                const data = new Float32Array(size * 4);
                
                for (let i = 0; i < size; i++) {
                    const baseIndex = i * 4;
                    data[baseIndex] = Math.random() * 100;        // Value 1
                    data[baseIndex + 1] = Math.random() * 360;    // Value 2
                    data[baseIndex + 2] = Math.floor(Math.random() * 10); // Category
                    data[baseIndex + 3] = Math.random() * 1000;   // Timestamp
                }
                
                return data;
            }
            
            testMemoryEfficiency() {
                this.log('Testing memory efficiency...', 'info', 'dataGenResults');
                
                const testSize = 1000000; // 1M rows
                const iterations = 10;
                const memorySnapshots = [];
                
                for (let i = 0; i < iterations; i++) {
                    if (performance.memory) {
                        const beforeMemory = performance.memory.usedJSHeapSize;
                        
                        // Generate and immediately discard data
                        const data = this.generateTestData(testSize);
                        const afterMemory = performance.memory.usedJSHeapSize;
                        
                        const memoryIncrease = afterMemory - beforeMemory;
                        memorySnapshots.push(memoryIncrease);
                        
                        this.log(`Iteration ${i + 1}: Memory increase: ${Math.round(memoryIncrease / 1024 / 1024)}MB`, 'info', 'dataGenResults');
                        
                        // Force garbage collection if available
                        if (window.gc) {
                            window.gc();
                        }
                        
                        // Small delay
                        setTimeout(() => {}, 100);
                    }
                }
                
                const avgMemoryIncrease = memorySnapshots.reduce((sum, val) => sum + val, 0) / memorySnapshots.length;
                this.log(`Average memory increase: ${Math.round(avgMemoryIncrease / 1024 / 1024)}MB`, 'success', 'dataGenResults');
            }
            
            testTypedArrayPerformance() {
                this.log('Testing TypedArray vs Array performance...', 'info', 'dataGenResults');
                
                const testSize = 1000000; // 1M elements
                
                // Test TypedArray
                const startTime1 = performance.now();
                const typedArray = new Float32Array(testSize);
                for (let i = 0; i < testSize; i++) {
                    typedArray[i] = Math.random();
                }
                const typedArrayTime = performance.now() - startTime1;
                
                // Test regular Array
                const startTime2 = performance.now();
                const regularArray = new Array(testSize);
                for (let i = 0; i < testSize; i++) {
                    regularArray[i] = Math.random();
                }
                const regularArrayTime = performance.now() - startTime2;
                
                const speedup = regularArrayTime / typedArrayTime;
                
                this.log(`TypedArray: ${Math.round(typedArrayTime)}ms`, 'info', 'dataGenResults');
                this.log(`Regular Array: ${Math.round(regularArrayTime)}ms`, 'info', 'dataGenResults');
                this.log(`TypedArray is ${speedup.toFixed(2)}x faster!`, 'success', 'dataGenResults');
            }
            
            // Chart Rendering Performance Tests
            testChartRendering() {
                this.log('Testing chart rendering performance...', 'info', 'chartResults');
                
                if (!this.testData) {
                    this.testData = this.generateTestData(1000000); // 1M rows
                }
                
                const iterations = 100;
                const renderTimes = [];
                
                for (let i = 0; i < iterations; i++) {
                    const startTime = performance.now();
                    this.renderTestChart();
                    const endTime = performance.now();
                    
                    renderTimes.push(endTime - startTime);
                }
                
                const avgRenderTime = renderTimes.reduce((sum, time) => sum + time, 0) / renderTimes.length;
                const minRenderTime = Math.min(...renderTimes);
                const maxRenderTime = Math.max(...renderTimes);
                
                this.log(`Chart rendering performance test completed!`, 'success', 'chartResults');
                this.log(`Average render time: ${avgRenderTime.toFixed(2)}ms`, 'info', 'chartResults');
                this.log(`Min render time: ${minRenderTime.toFixed(2)}ms`, 'info', 'chartResults');
                this.log(`Max render time: ${maxRenderTime.toFixed(2)}ms`, 'info', 'chartResults');
                this.log(`Target: < 16ms for 60 FPS`, 'info', 'chartResults');
                
                if (avgRenderTime < 16) {
                    this.log('‚úÖ Excellent performance! Maintaining 60+ FPS', 'success', 'chartResults');
                } else if (avgRenderTime < 33) {
                    this.log('‚ö†Ô∏è Good performance, but could be optimized for 60 FPS', 'warning', 'chartResults');
                } else {
                    this.log('‚ùå Performance needs improvement for smooth rendering', 'error', 'chartResults');
                }
            }
            
            renderTestChart() {
                const ctx = this.testChartCtx;
                const canvas = ctx.canvas;
                
                // Clear canvas
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw a simple histogram
                const dataLength = this.testData.length / 4;
                const sampleSize = Math.min(1000, dataLength);
                const step = Math.max(1, Math.floor(dataLength / sampleSize));
                
                const bins = new Array(50).fill(0);
                const maxValue = 100;
                
                // Count data into bins
                for (let i = 0; i < dataLength; i += step) {
                    const value = this.testData[i * 4];
                    const binIndex = Math.min(Math.floor((value / maxValue) * 50), 49);
                    bins[binIndex]++;
                }
                
                const maxBin = Math.max(...bins);
                
                // Draw histogram
                ctx.fillStyle = '#00ff00';
                const barWidth = canvas.width / 50;
                const barHeight = canvas.height * 0.8;
                
                for (let i = 0; i < 50; i++) {
                    const x = i * barWidth;
                    const height = (bins[i] / maxBin) * barHeight;
                    const y = canvas.height - height;
                    
                    ctx.fillRect(x, y, barWidth - 1, height);
                }
            }
            
            testMultiChartPerformance() {
                this.log('Testing multi-chart performance...', 'info', 'chartResults');
                
                const chartCounts = [1, 4, 8, 16];
                const results = [];
                
                for (const count of chartCounts) {
                    const startTime = performance.now();
                    
                    // Simulate rendering multiple charts
                    for (let i = 0; i < count; i++) {
                        this.renderTestChart();
                    }
                    
                    const endTime = performance.now();
                    const totalTime = endTime - startTime;
                    const avgTimePerChart = totalTime / count;
                    
                    results.push({ chartCount: count, totalTime, avgTimePerChart });
                    
                    this.log(`${count} charts: ${Math.round(totalTime)}ms total, ${avgTimePerChart.toFixed(2)}ms per chart`, 'info', 'chartResults');
                }
                
                this.log('Multi-chart performance test completed!', 'success', 'chartResults');
            }
            
            // Data Processing Performance Tests
            testFiltering() {
                this.log('Testing filtering performance...', 'info', 'processingResults');
                
                if (!this.testData) {
                    this.testData = this.generateTestData(1000000); // 1M rows
                }
                
                const dataLength = this.testData.length / 4;
                const filterThreshold = 50;
                
                const startTime = performance.now();
                
                // Filter data using TypedArray for performance
                const filteredIndices = [];
                for (let i = 0; i < dataLength; i++) {
                    if (this.testData[i * 4] > filterThreshold) {
                        filteredIndices.push(i);
                    }
                }
                
                const endTime = performance.now();
                const filterTime = endTime - startTime;
                const filteredCount = filteredIndices.length;
                
                document.getElementById('filterTime').textContent = Math.round(filterTime) + 'ms';
                
                this.log(`Filtered ${filteredCount.toLocaleString()} rows in ${Math.round(filterTime)}ms`, 'success', 'processingResults');
                this.log(`Filter rate: ${Math.round(filteredCount / (filterTime / 1000)).toLocaleString()} rows/sec`, 'info', 'processingResults');
            }
            
            testSorting() {
                this.log('Testing sorting performance...', 'info', 'processingResults');
                
                if (!this.testData) {
                    this.testData = this.generateTestData(1000000); // 1M rows
                }
                
                const dataLength = this.testData.length / 4;
                const valuesToSort = new Float32Array(dataLength);
                
                // Extract values to sort
                for (let i = 0; i < dataLength; i++) {
                    valuesToSort[i] = this.testData[i * 4];
                }
                
                const startTime = performance.now();
                
                // Sort the values
                valuesToSort.sort((a, b) => a - b);
                
                const endTime = performance.now();
                const sortTime = endTime - startTime;
                
                document.getElementById('sortTime').textContent = Math.round(sortTime) + 'ms';
                
                this.log(`Sorted ${dataLength.toLocaleString()} values in ${Math.round(sortTime)}ms`, 'success', 'processingResults');
                this.log(`Sort rate: ${Math.round(dataLength / (sortTime / 1000)).toLocaleString()} values/sec`, 'info', 'processingResults');
            }
            
            testAggregation() {
                this.log('Testing aggregation performance...', 'info', 'processingResults');
                
                if (!this.testData) {
                    this.testData = this.generateTestData(1000000); // 1M rows
                }
                
                const dataLength = this.testData.length / 4;
                
                const startTime = performance.now();
                
                // Calculate basic statistics
                let sum = 0;
                let min = Infinity;
                let max = -Infinity;
                
                for (let i = 0; i < dataLength; i++) {
                    const value = this.testData[i * 4];
                    sum += value;
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                }
                
                const mean = sum / dataLength;
                
                const endTime = performance.now();
                const aggTime = endTime - startTime;
                
                document.getElementById('aggTime').textContent = Math.round(aggTime) + 'ms';
                
                this.log(`Aggregated ${dataLength.toLocaleString()} values in ${Math.round(aggTime)}ms`, 'success', 'processingResults');
                this.log(`Mean: ${mean.toFixed(2)}, Min: ${min.toFixed(2)}, Max: ${max.toFixed(2)}`, 'info', 'processingResults');
            }
            
            // Real-time Update Performance Tests
            startRealTimeTest() {
                if (this.isRealTimeTesting) return;
                
                this.isRealTimeTesting = true;
                this.log('Starting real-time performance test...', 'info', 'realtimeResults');
                
                let frameCount = 0;
                let lastTime = performance.now();
                
                this.realTimeInterval = setInterval(() => {
                    const currentTime = performance.now();
                    frameCount++;
                    
                    if (currentTime - lastTime >= 1000) {
                        const fps = Math.round(frameCount * 1000 / (currentTime - lastTime));
                        document.getElementById('renderFPS').textContent = fps;
                        
                        frameCount = 0;
                        lastTime = currentTime;
                    }
                    
                    // Update test data
                    this.updateTestData();
                    
                    // Render chart
                    this.renderTestChart();
                    
                    // Update metrics
                    this.updateRealTimeMetrics();
                }, 16); // ~60 FPS
                
                this.log('Real-time test started at ~60 FPS', 'success', 'realtimeResults');
            }
            
            stopRealTimeTest() {
                if (!this.isRealTimeTesting) return;
                
                this.isRealTimeTesting = false;
                if (this.realTimeInterval) {
                    clearInterval(this.realTimeInterval);
                    this.realTimeInterval = null;
                }
                
                this.log('Real-time test stopped', 'info', 'realtimeResults');
            }
            
            updateTestData() {
                if (!this.testData) return;
                
                const dataLength = this.testData.length / 4;
                const updateCount = Math.min(1000, Math.floor(dataLength * 0.001));
                
                for (let i = 0; i < updateCount; i++) {
                    const randomIndex = Math.floor(Math.random() * dataLength);
                    const baseIndex = randomIndex * 4;
                    
                    // Add noise to existing values
                    this.testData[baseIndex] = Math.max(0, Math.min(100, this.testData[baseIndex] + (Math.random() - 0.5) * 5));
                }
            }
            
            updateRealTimeMetrics() {
                // Update rate
                this.performanceMetrics = this.performanceMetrics || { updateCount: 0, lastUpdateTime: performance.now() };
                this.performanceMetrics.updateCount++;
                
                const now = performance.now();
                if (now - this.performanceMetrics.lastUpdateTime >= 1000) {
                    const updatesPerSecond = Math.round(this.performanceMetrics.updateCount * 1000 / (now - this.performanceMetrics.lastUpdateTime));
                    document.getElementById('updateRate').textContent = updatesPerSecond;
                    
                    this.performanceMetrics.updateCount = 0;
                    this.performanceMetrics.lastUpdateTime = now;
                }
            }
            
            // Memory Monitoring
            monitorMemory() {
                if (this.memoryMonitoring) return;
                
                this.memoryMonitoring = true;
                this.log('Starting memory monitoring...', 'info', 'memoryResults');
                
                this.memoryInterval = setInterval(() => {
                    if (performance.memory) {
                        const heapSize = Math.round(performance.memory.totalJSHeapSize / 1024 / 1024);
                        const heapUsed = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                        const memoryPressure = Math.round((performance.memory.usedJSHeapSize / performance.memory.totalJSHeapSize) * 100);
                        
                        document.getElementById('heapSize').textContent = heapSize + 'MB';
                        document.getElementById('heapUsed').textContent = heapUsed + 'MB';
                        document.getElementById('memoryPressure').textContent = memoryPressure + '%';
                        
                        if (memoryPressure > 80) {
                            this.log(`‚ö†Ô∏è High memory pressure: ${memoryPressure}%`, 'warning', 'memoryResults');
                        }
                    }
                }, 1000);
                
                this.log('Memory monitoring started', 'success', 'memoryResults');
            }
            
            testGarbageCollection() {
                this.log('Testing garbage collection...', 'info', 'memoryResults');
                
                if (window.gc) {
                    const beforeMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                    
                    // Create some temporary objects
                    for (let i = 0; i < 1000000; i++) {
                        const temp = { data: new Array(100).fill(Math.random()) };
                    }
                    
                    const afterMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                    const memoryIncrease = afterMemory - beforeMemory;
                    
                    this.log(`Memory before GC: ${Math.round(beforeMemory / 1024 / 1024)}MB`, 'info', 'memoryResults');
                    this.log(`Memory after creating objects: ${Math.round(afterMemory / 1024 / 1024)}MB`, 'info', 'memoryResults');
                    
                    // Force garbage collection
                    window.gc();
                    
                    const afterGCMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                    const memoryFreed = afterMemory - afterGCMemory;
                    
                    this.log(`Memory after GC: ${Math.round(afterGCMemory / 1024 / 1024)}MB`, 'info', 'memoryResults');
                    this.log(`Memory freed: ${Math.round(memoryFreed / 1024 / 1024)}MB`, 'success', 'memoryResults');
                } else {
                    this.log('Garbage collection not available in this browser', 'warning', 'memoryResults');
                }
            }
        }
        
        // Initialize test suite
        let testSuite;
        window.addEventListener('load', () => {
            testSuite = new PerformanceTestSuite();
        });
        
        // Add some global utility functions
        window.testSuite = null;
        
        // Performance monitoring
        let lastTime = performance.now();
        let frameCount = 0;
        
        function measurePerformance(currentTime) {
            frameCount++;
            
            if (currentTime - lastTime >= 1000) {
                const fps = Math.round(frameCount * 1000 / (currentTime - lastTime));
                document.getElementById('renderFPS').textContent = fps;
                
                frameCount = 0;
                lastTime = currentTime;
            }
            
            requestAnimationFrame(measurePerformance);
        }
        
        requestAnimationFrame(measurePerformance);
    </script>
</body>
</html>
