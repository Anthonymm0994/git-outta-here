<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robust Chart System - Error-Free Implementation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
            color: #ffffff;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00ff88, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .controls {
            background: rgba(26, 26, 46, 0.9);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-group label {
            font-weight: bold;
            color: #00ff88;
        }
        
        .control-group select, .control-group button {
            padding: 8px 12px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 14px;
        }
        
        .control-group button {
            background: #00ff88;
            border: none;
            cursor: pointer;
            color: #000;
            font-weight: bold;
        }
        
        .control-group button:hover {
            background: #00cc6a;
        }
        
        .chart-container {
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #333;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .chart-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 15px;
        }
        
        .chart-canvas {
            border: 1px solid #333;
            border-radius: 8px;
            background: #000;
            width: 100%;
            height: 300px;
        }
        
        .error-log {
            background: rgba(255, 71, 87, 0.1);
            border: 1px solid #ff4757;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .error-log h3 {
            color: #ff4757;
            margin-bottom: 10px;
        }
        
        .status {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .status h3 {
            color: #00ff88;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Robust Chart System</h1>
        <p>Error-Free Implementation with Proper Initialization</p>
    </div>
    
    <div class="controls">
        <div class="control-group">
            <label>Chart Type:</label>
            <select id="chartType">
                <option value="histogram">Histogram</option>
                <option value="line">Line Chart</option>
                <option value="scatter">Scatter Plot</option>
                <option value="bar">Bar Chart</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Data Size:</label>
            <select id="dataSize">
                <option value="100">100 Points</option>
                <option value="1000">1K Points</option>
                <option value="10000">10K Points</option>
            </select>
        </div>
        
        <button id="generateData">Generate Data</button>
        <button id="createChart">Create Chart</button>
        <button id="clearCharts">Clear All</button>
    </div>
    
    <div id="chartsContainer">
        <!-- Charts will be created here -->
    </div>
    
    <div class="status">
        <h3>System Status</h3>
        <div id="statusText">Ready to create charts</div>
    </div>
    
    <div class="error-log" id="errorLog" style="display: none;">
        <h3>Error Log</h3>
        <div id="errorText"></div>
    </div>
    
    <script>
        // Global error handler
        window.addEventListener('error', function(e) {
            console.error('Global error caught:', e.error);
            logError(`Global Error: ${e.error.message} at ${e.filename}:${e.lineno}`);
        });
        
        // Global promise rejection handler
        window.addEventListener('unhandledrejection', function(e) {
            console.error('Unhandled promise rejection:', e.reason);
            logError(`Promise Rejection: ${e.reason}`);
        });
        
        // Error logging function
        function logError(message) {
            const errorLog = document.getElementById('errorLog');
            const errorText = document.getElementById('errorText');
            
            const timestamp = new Date().toLocaleTimeString();
            errorText.innerHTML += `[${timestamp}] ${message}<br>`;
            
            errorLog.style.display = 'block';
            errorLog.scrollTop = errorLog.scrollHeight;
        }
        
        // Status update function
        function updateStatus(message) {
            document.getElementById('statusText').textContent = message;
        }
        
        // Data generation function
        function generateTestData(size) {
            try {
                const data = [];
                for (let i = 0; i < size; i++) {
                    data.push({
                        x: i,
                        y: Math.random() * 100,
                        category: Math.floor(Math.random() * 5),
                        value: Math.random() * 1000
                    });
                }
                return data;
            } catch (error) {
                logError(`Data generation error: ${error.message}`);
                return [];
            }
        }
        
        // Base Chart Class - PROPERLY INITIALIZED
        class BaseChart {
            constructor(canvas, config = {}) {
                // CRITICAL: Initialize ALL properties before any method calls
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                
                // Default configuration with fallbacks
                this.config = {
                    width: canvas.offsetWidth || 400,
                    height: canvas.offsetHeight || 300,
                    margin: {
                        top: 20,
                        right: 20,
                        bottom: 40,
                        left: 40
                    },
                    colors: ['#00ff88', '#00d4ff', '#ff6b6b', '#feca57', '#4ecdc4'],
                    backgroundColor: '#000000',
                    gridColor: '#333333',
                    textColor: '#ffffff',
                    ...config
                };
                
                // Initialize internal state
                this.data = [];
                this.isInitialized = false;
                this.errorState = null;
                
                // Set up canvas properly
                this.setupCanvas();
                
                // Mark as initialized
                this.isInitialized = true;
            }
            
            setupCanvas() {
                try {
                    // Set canvas size for high DPI displays
                    const dpr = window.devicePixelRatio || 1;
                    this.canvas.width = this.config.width * dpr;
                    this.canvas.height = this.config.height * dpr;
                    this.ctx.scale(dpr, dpr);
                    
                    // Set canvas CSS size
                    this.canvas.style.width = this.config.width + 'px';
                    this.canvas.style.height = this.config.height + 'px';
                    
                    // Clear canvas
                    this.clear();
                } catch (error) {
                    this.errorState = `Canvas setup error: ${error.message}`;
                    logError(this.errorState);
                }
            }
            
            clear() {
                try {
                    if (!this.ctx) return;
                    
                    this.ctx.fillStyle = this.config.backgroundColor;
                    this.ctx.fillRect(0, 0, this.config.width, this.config.height);
                } catch (error) {
                    logError(`Clear error: ${error.message}`);
                }
            }
            
            setData(data) {
                try {
                    if (!Array.isArray(data)) {
                        throw new Error('Data must be an array');
                    }
                    
                    this.data = data;
                    this.draw();
                } catch (error) {
                    this.errorState = `Data setting error: ${error.message}`;
                    logError(this.errorState);
                }
            }
            
            draw() {
                try {
                    // Safety checks
                    if (!this.isInitialized) {
                        throw new Error('Chart not initialized');
                    }
                    
                    if (!this.ctx) {
                        throw new Error('Canvas context not available');
                    }
                    
                    if (!this.config || !this.config.margin) {
                        throw new Error('Configuration or margin not properly initialized');
                    }
                    
                    // Clear and draw
                    this.clear();
                    this.drawGrid();
                    this.drawData();
                    this.drawLabels();
                    
                } catch (error) {
                    this.errorState = `Draw error: ${error.message}`;
                    logError(this.errorState);
                    this.drawErrorState();
                }
            }
            
            drawGrid() {
                try {
                    if (!this.ctx || !this.config.margin) return;
                    
                    const { margin } = this.config;
                    const chartWidth = this.config.width - margin.left - margin.right;
                    const chartHeight = this.config.height - margin.top - margin.bottom;
                    
                    this.ctx.strokeStyle = this.config.gridColor;
                    this.ctx.lineWidth = 1;
                    
                    // Vertical grid lines
                    for (let i = 0; i <= 10; i++) {
                        const x = margin.left + (i / 10) * chartWidth;
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, margin.top);
                        this.ctx.lineTo(x, margin.top + chartHeight);
                        this.ctx.stroke();
                    }
                    
                    // Horizontal grid lines
                    for (let i = 0; i <= 10; i++) {
                        const y = margin.top + (i / 10) * chartHeight;
                        this.ctx.beginPath();
                        this.ctx.moveTo(margin.left, y);
                        this.ctx.lineTo(margin.left + chartWidth, y);
                        this.ctx.stroke();
                    }
                } catch (error) {
                    logError(`Grid drawing error: ${error.message}`);
                }
            }
            
            drawData() {
                // Override in subclasses
                try {
                    if (this.data.length === 0) return;
                    
                    // Default data visualization
                    this.ctx.fillStyle = this.config.colors[0];
                    this.data.forEach((point, index) => {
                        if (point && typeof point.x === 'number' && typeof point.y === 'number') {
                            const x = this.config.margin.left + (point.x / Math.max(...this.data.map(d => d.x))) * 
                                    (this.config.width - this.config.margin.left - this.config.margin.right);
                            const y = this.config.margin.top + (1 - point.y / Math.max(...this.data.map(d => d.y))) * 
                                    (this.config.height - this.config.margin.top - this.config.margin.bottom);
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    });
                } catch (error) {
                    logError(`Data drawing error: ${error.message}`);
                }
            }
            
            drawLabels() {
                try {
                    if (!this.ctx || !this.config.margin) return;
                    
                    this.ctx.fillStyle = this.config.textColor;
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    
                    // X-axis label
                    this.ctx.fillText('X Axis', this.config.width / 2, this.config.height - 10);
                    
                    // Y-axis label
                    this.ctx.save();
                    this.ctx.translate(20, this.config.height / 2);
                    this.ctx.rotate(-Math.PI / 2);
                    this.ctx.fillText('Y Axis', 0, 0);
                    this.ctx.restore();
                } catch (error) {
                    logError(`Label drawing error: ${error.message}`);
                }
            }
            
            drawErrorState() {
                try {
                    if (!this.ctx) return;
                    
                    this.ctx.fillStyle = '#ff4757';
                    this.ctx.font = '14px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Chart Error', this.config.width / 2, this.config.height / 2 - 10);
                    this.ctx.fillText(this.errorState || 'Unknown error', this.config.width / 2, this.config.height / 2 + 10);
                } catch (error) {
                    logError(`Error state drawing error: ${error.message}`);
                }
            }
            
            resize(newWidth, newHeight) {
                try {
                    this.config.width = newWidth;
                    this.config.height = newHeight;
                    this.setupCanvas();
                    this.draw();
                } catch (error) {
                    logError(`Resize error: ${error.message}`);
                }
            }
        }
        
        // Histogram Chart - PROPERLY EXTENDS BaseChart
        class HistogramChart extends BaseChart {
            constructor(canvas, config = {}) {
                // CRITICAL: Call parent constructor first
                super(canvas, config);
                
                // Additional histogram-specific properties
                this.binCount = config.binCount || 20;
                this.bins = [];
            }
            
            drawData() {
                try {
                    if (!this.ctx || !this.config.margin || this.data.length === 0) return;
                    
                    const { margin } = this.config;
                    const chartWidth = this.config.width - margin.left - margin.right;
                    const chartHeight = this.config.height - margin.top - margin.bottom;
                    
                    // Calculate bins
                    this.calculateBins();
                    
                    // Find max bin value
                    const maxBin = Math.max(...this.bins);
                    if (maxBin === 0) return;
                    
                    // Draw histogram bars
                    const barWidth = chartWidth / this.binCount;
                    
                    this.ctx.fillStyle = this.config.colors[0];
                    for (let i = 0; i < this.binCount; i++) {
                        const barHeight = (this.bins[i] / maxBin) * chartHeight;
                        const x = margin.left + i * barWidth;
                        const y = margin.top + chartHeight - barHeight;
                        
                        this.ctx.fillRect(x, y, barWidth - 1, barHeight);
                    }
                } catch (error) {
                    logError(`Histogram drawing error: ${error.message}`);
                }
            }
            
            calculateBins() {
                try {
                    if (this.data.length === 0) {
                        this.bins = new Array(this.binCount).fill(0);
                        return;
                    }
                    
                    // Get Y values for binning
                    const yValues = this.data.map(d => d.y).filter(y => typeof y === 'number');
                    if (yValues.length === 0) {
                        this.bins = new Array(this.binCount).fill(0);
                        return;
                    }
                    
                    const min = Math.min(...yValues);
                    const max = Math.max(...yValues);
                    const binSize = (max - min) / this.binCount || 1;
                    
                    this.bins = new Array(this.binCount).fill(0);
                    
                    yValues.forEach(value => {
                        const binIndex = Math.min(Math.floor((value - min) / binSize), this.binCount - 1);
                        if (binIndex >= 0 && binIndex < this.binCount) {
                            this.bins[binIndex]++;
                        }
                    });
                } catch (error) {
                    logError(`Bin calculation error: ${error.message}`);
                    this.bins = new Array(this.binCount).fill(0);
                }
            }
        }
        
        // Line Chart - PROPERLY EXTENDS BaseChart
        class LineChart extends BaseChart {
            constructor(canvas, config = {}) {
                super(canvas, config);
                this.lineWidth = config.lineWidth || 2;
            }
            
            drawData() {
                try {
                    if (!this.ctx || !this.config.margin || this.data.length < 2) return;
                    
                    const { margin } = this.config;
                    const chartWidth = this.config.width - margin.left - margin.right;
                    const chartHeight = this.config.height - margin.top - margin.bottom;
                    
                    // Sort data by X value
                    const sortedData = [...this.data].sort((a, b) => a.x - b.x);
                    
                    this.ctx.strokeStyle = this.config.colors[0];
                    this.ctx.lineWidth = this.lineWidth;
                    this.ctx.beginPath();
                    
                    sortedData.forEach((point, index) => {
                        if (point && typeof point.x === 'number' && typeof point.y === 'number') {
                            const x = margin.left + (point.x / Math.max(...sortedData.map(d => d.x))) * chartWidth;
                            const y = margin.top + (1 - point.y / Math.max(...sortedData.map(d => d.y))) * chartHeight;
                            
                            if (index === 0) {
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                    });
                    
                    this.ctx.stroke();
                } catch (error) {
                    logError(`Line chart drawing error: ${error.message}`);
                }
            }
        }
        
        // Chart Manager - PROPERLY MANAGES CHARTS
        class ChartManager {
            constructor() {
                this.charts = new Map();
                this.chartCounter = 0;
            }
            
            createChart(type, canvas, config = {}) {
                try {
                    let chart;
                    
                    switch (type) {
                        case 'histogram':
                            chart = new HistogramChart(canvas, config);
                            break;
                        case 'line':
                            chart = new LineChart(canvas, config);
                            break;
                        case 'scatter':
                            chart = new BaseChart(canvas, config);
                            break;
                        case 'bar':
                            chart = new BaseChart(canvas, config);
                            break;
                        default:
                            throw new Error(`Unknown chart type: ${type}`);
                    }
                    
                    const chartId = `chart_${this.chartCounter++}`;
                    this.charts.set(chartId, chart);
                    
                    return { id: chartId, chart: chart };
                } catch (error) {
                    logError(`Chart creation error: ${error.message}`);
                    return null;
                }
            }
            
            getChart(chartId) {
                return this.charts.get(chartId);
            }
            
            removeChart(chartId) {
                try {
                    const chart = this.charts.get(chartId);
                    if (chart && chart.canvas) {
                        chart.canvas.remove();
                    }
                    this.charts.delete(chartId);
                } catch (error) {
                    logError(`Chart removal error: ${error.message}`);
                }
            }
            
            clearAllCharts() {
                try {
                    this.charts.forEach((chart, id) => {
                        this.removeChart(id);
                    });
                    this.charts.clear();
                    this.chartCounter = 0;
                } catch (error) {
                    logError(`Clear all charts error: ${error.message}`);
                }
            }
            
            resizeAllCharts() {
                try {
                    this.charts.forEach((chart) => {
                        if (chart.canvas && chart.resize) {
                            chart.resize(chart.canvas.offsetWidth, chart.canvas.offsetHeight);
                        }
                    });
                } catch (error) {
                    logError(`Resize all charts error: ${error.message}`);
                }
            }
        }
        
        // Main Application
        class ChartApplication {
            constructor() {
                this.chartManager = new ChartManager();
                this.currentData = [];
                this.setupEventListeners();
                updateStatus('Application initialized successfully');
            }
            
            setupEventListeners() {
                try {
                    document.getElementById('generateData').addEventListener('click', () => {
                        this.generateData();
                    });
                    
                    document.getElementById('createChart').addEventListener('click', () => {
                        this.createChart();
                    });
                    
                    document.getElementById('clearCharts').addEventListener('click', () => {
                        this.clearCharts();
                    });
                    
                    // Handle window resize
                    window.addEventListener('resize', () => {
                        setTimeout(() => {
                            this.chartManager.resizeAllCharts();
                        }, 100);
                    });
                    
                } catch (error) {
                    logError(`Event listener setup error: ${error.message}`);
                }
            }
            
            generateData() {
                try {
                    const size = parseInt(document.getElementById('dataSize').value);
                    this.currentData = generateTestData(size);
                    updateStatus(`Generated ${size} data points successfully`);
                } catch (error) {
                    logError(`Data generation error: ${error.message}`);
                    updateStatus('Error generating data');
                }
            }
            
            createChart() {
                try {
                    if (this.currentData.length === 0) {
                        updateStatus('Please generate data first');
                        return;
                    }
                    
                    const chartType = document.getElementById('chartType').value;
                    
                    // Create chart container
                    const container = document.createElement('div');
                    container.className = 'chart-container';
                    
                    const title = document.createElement('div');
                    title.className = 'chart-title';
                    title.textContent = `${chartType.charAt(0).toUpperCase() + chartType.slice(1)} Chart`;
                    
                    const canvas = document.createElement('canvas');
                    canvas.className = 'chart-canvas';
                    
                    container.appendChild(title);
                    container.appendChild(canvas);
                    
                    document.getElementById('chartsContainer').appendChild(container);
                    
                    // Create chart instance
                    const chartResult = this.chartManager.createChart(chartType, canvas, {
                        width: 600,
                        height: 300,
                        binCount: 20
                    });
                    
                    if (chartResult) {
                        // Set data and draw
                        chartResult.chart.setData(this.currentData);
                        updateStatus(`Created ${chartType} chart successfully`);
                    } else {
                        updateStatus('Failed to create chart');
                    }
                    
                } catch (error) {
                    logError(`Chart creation error: ${error.message}`);
                    updateStatus('Error creating chart');
                }
            }
            
            clearCharts() {
                try {
                    this.chartManager.clearAllCharts();
                    document.getElementById('chartsContainer').innerHTML = '';
                    updateStatus('All charts cleared');
                } catch (error) {
                    logError(`Clear charts error: ${error.message}`);
                    updateStatus('Error clearing charts');
                }
            }
        }
        
        // Initialize application when page loads
        window.addEventListener('load', () => {
            try {
                window.chartApp = new ChartApplication();
                updateStatus('Application ready');
            } catch (error) {
                logError(`Application initialization error: ${error.message}`);
                updateStatus('Failed to initialize application');
            }
        });
    </script>
</body>
</html>


